#include <iostream>
#include <stdio.h>
#include <math.h>
#define ABS(x) (x < 0 ? -(x) : x)
using namespace std;

struct POS {
	int x;
	int y;
};

int tCnt;      // 테스트 케이스 갯수
int tN;        // 집, 회사, 고객의 수 합
POS pArr[100]; // 좌표 데이터 배열
int solve(POS pos, int dis, int visited);
int distance(POS pos1, POS pos2);

int main() {
	//  freopen("test.txt", "r", stdin);

	cin >> tCnt;
	int N; // 고갯의 수
	for (int t = 1; t <= tCnt; ++t) {
		cin >> N;
		tN = N + 2;
		for (int n = 0; n < tN; ++n) // 좌표 데이터 배열에 입력
			cin >> pArr[n].x >> pArr[n].y;

		POS temp;
		temp = pArr[tN - 1];      //마지막 입력값과 도착지(집)의 값 swap
		pArr[tN - 1] = pArr[1];
		pArr[1] = temp;

		int min = solve(pArr[0], 0, 1);         //함수
		cout << "#" << t << "\t" << min << endl;
	}

	return 0;
}


int solve(POS pos, int dis, int visited) {

	int temp = 999999999;
	int dist = 999999999; // 반환할 최소거리값
	int MIN = 999999999;  // 최종적으로 반환하는 최소 거리값

	if (visited == ((1 << (tN - 1)) - 1)) {       //
		dist = dis + distance(pos, pArr[tN - 1]);
		return dist;
	}

	for (int i = 1; i < tN - 1; ++i) {
		if (visited & (1 << i))
			continue;

		dist = dis + distance(pos, pArr[i]);  // 이전의 값 + 새로운 거리값

		temp = solve(pArr[i], dist, visited | (1 << i));

		if (temp < MIN)                      // 기존의 합보다 작을경우 더 작은값
			MIN = temp;
	}

	return MIN;
}

int distance(POS pos1, POS pos2) {  // 두 좌표의 거리 연산 반환

	int dis = ABS(pos1.x - pos2.x) + ABS(pos1.y - pos2.y);

	return dis;
}
